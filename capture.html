<!DOCTYPE html>
<html >
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <title>capture</title>

  <script src="libs/opencv.js"></script>
  <script src="functions.js"></script>

  <style>
      video {
          display: none;
      }
  </style>
</head>
<body>

  <button id="captureStop">SHOT !</button> <span id="resolutionContainer">RESOLUTION</span>
  <div class="demo-frame">
    <div class="demo-container">
      <!--<img id="image" src="./tile1.png">-->
      <!--<img id="input" src="./tile9.png">-->
      <img id="input">
      <!--<img id="image2" src="./tile1.png">-->
      <div style="position: relative">
      <canvas id="canvasOutput0" width="600" height="300" style="opacity: 1"></canvas>
      <canvas id="canvasOutputOverlay" width="600" height="300" style="position: absolute; top: 0; left:0; opacity: 0.6"></canvas>
      </div>
      <div id="cutSets"></div>
      <canvas id="canvasOutput" width="600" height="300" style="display: none"></canvas>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
        console.log('READY', window.location.hash);
            run(document.querySelector('video'));
    });

    function randColor() {
        return new cv.Scalar(Math.round(Math.random() * 255), Math.round(Math.random() * 255),
                                      Math.round(Math.random() * 255), 1);
    }

    function run() {

        document.getElementById('captureStop').addEventListener('click', () => {
            feed.stop();

            processVideoFull(feed.getLastFrame());
        });

        // let feed = new ConstantVideoFeed('IMG_20180729_231128.jpg');
        let feed = new VideoStreamFeed(navigator.mediaDevices);

        feed.onFrame.addListener(canvas => {
            processVideoFast(canvas);

            // processVideoFull(canvas);
            // feed.stop();
        });

        feed.start();

        function processVideoFast(canvas) {

            let orig = cv.imread(canvas);
            let src = new cv.Mat();

            document.getElementById('resolutionContainer').innerHTML = `${orig.size().width} x ${orig.size().height}`;

            let SCALE = 1.0;
            let MIN_AREA = 2000;

            orig.copyTo(src);
            // cv.resize(orig, src, new cv.Size(0,0), 1/SCALE, 1/SCALE, cv.INTER_AREA);
            let overlay = cv.Mat.ones(src.rows, src.cols, cv.CV_8UC3);

            // let overlay = cv.Mat.ones(src.rows, src.cols, cv.CV_8UC3);

            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
            cv.threshold(src, src, 150, 255, cv.THRESH_BINARY);

            let contours = getImportantContours(src, MIN_AREA);

            contours.forEach(cnt => {
                // drawCnt(overlay, cnt);
                drawBBRect(overlay, cnt.bbox, randColor())
            });

             cv.imshow('canvasOutput0', orig);
             cv.imshow('canvasOutputOverlay', overlay);
        }

        function processVideoFull(canvas) {
            let orig = cv.imread(canvas);
            let src = new cv.Mat();

            document.getElementById('resolutionContainer').innerHTML = `${orig.size().width} x ${orig.size().height}`;

            let SCALE = 1.0;
            let MIN_AREA = 2000;


            cv.resize(orig, src, new cv.Size(0, 0), 1 / SCALE, 1 / SCALE, cv.INTER_AREA);

            let overlay = cv.Mat.ones(src.rows, src.cols, cv.CV_8UC3);

            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
            cv.threshold(src, src, 150, 255, cv.THRESH_BINARY);

            let contours = getImportantContours(src, MIN_AREA);

            // cv.cvtColor(src, src, cv.COLOR_GRAY2RGB, 0);

            contours.forEach(cnt => {
                drawCnt(overlay, cnt);
            });

            cv.imshow('canvasOutput0', src);

            cutContours(orig, contours, SCALE).forEach(item => { // .slice(22)


                cv.cvtColor(item.mat, item.mat, cv.COLOR_RGBA2GRAY, 0);
                cv.threshold(item.mat, item.mat, 130, 255, cv.THRESH_BINARY);

                // let bbb = cv.boundingRect(item.cnt);
                // drawBBRect(overlay, bbb, new cv.Scalar(255, 255, 255));

                try {
                    let target;
                    // try {
                        target = findContourAndFixPerspective(item.mat);
                    // }
                    // catch (e) {
                    //     console.error("FAILED TO FIND PERSPECTIVE");
                    //     return;
                    // }

                    let targetContours = getImportantContours(target.mat, 20);
                    let clusters = simpleClusterize(targetContours, 80);
                    console.log('AAAA', targetContours);
                    console.log('CLU', clusters);
                    let tiles = cutTilesFromClusters(target.mat, clusters, false);
                    tiles.forEach(tile => {

                        let cutCanvas = document.getElementById('cutSets').appendChild(document.createElement('canvas'));
                        cv.imshow(cutCanvas, tile.mat);
                    })
                }
                finally {
                    let cutCanvas = document.getElementById('cutSets').appendChild(document.createElement('canvas'));
                    cv.imshow(cutCanvas, item.mat);
                    // throw e;
                }


            });


            cv.imshow('canvasOutputOverlay', overlay);
        }
        

    }


  </script>


</body></html>