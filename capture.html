<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>capture</title>

  <script src="libs/opencv.js"></script>
  <script src="functions.js"></script>

<link rel="stylesheet" href="foundation.min.css">

  <style>
      video {
          display: none;
      }
  </style>
</head>
<body>

  <div class="demo-frame">
    <div class="demo-container">
      <!--<img id="image" src="./tile1.png">-->
      <!--<img id="input" src="./tile9.png">-->
      <img id="input">
      <!--<img id="image2" src="./tile1.png">-->
      <div style="position: relative">
      <canvas id="canvasOutput0" width="600" height="300" style="opacity: 1"></canvas>
      <canvas id="canvasOutputOverlay" width="600" height="300" style="position: absolute; top: 0; left:0; opacity: 0.6"></canvas>
      </div>
      <div id="cutSets"></div>
      <canvas id="canvasOutput" width="600" height="300" style="display: none"></canvas>
    </div>
  </div>

    <button class="button primary large" id="captureStop">SHOT !</button> <span id="resolutionContainer">RESOLUTION</span> <span id="fpsCounter">FPS</span>


  <script>
    document.addEventListener('DOMContentLoaded', () => {
        console.log('READY', window.location.hash);
            run(document.querySelector('video'));
    });

    function randColor() {
        return new cv.Scalar(Math.round(Math.random() * 255), Math.round(Math.random() * 255),
                                      Math.round(Math.random() * 255), 1);
    }

    function run() {

        document.getElementById('captureStop').addEventListener('click', () => {
            feed.stop();

            processVideoFull(feed.getLastFrame());
        });

        // let feed = new ConstantVideoFeed('IMG_20180729_231128.jpg');
        let feed = new VideoStreamFeed(navigator.mediaDevices, 5);

        feed.onFrame.addListener(canvas => {
            let d1 = new Date();
            processVideoFast(canvas);
            let d2 = new Date();

            document.getElementById('fpsCounter').innerText = (d2-d1) + ' ms';

            // processVideoFull(canvas);
            // feed.stop();
        });

        feed.start();

        function processVideoFast(canvas) {

            let orig = cv.imread(canvas);
            let src = new cv.Mat();

            document.getElementById('resolutionContainer').innerHTML = `${orig.size().width} x ${orig.size().height}`;

            let SCALE = 1.0;
            let MIN_AREA = 2000;

            orig.copyTo(src);
            // cv.resize(orig, src, new cv.Size(0,0), 1/SCALE, 1/SCALE, cv.INTER_AREA);
            let overlay = cv.Mat.ones(src.rows, src.cols, cv.CV_8UC3);

            // let overlay = cv.Mat.ones(src.rows, src.cols, cv.CV_8UC3);

            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
            cv.threshold(src, src, 150, 255, cv.THRESH_BINARY);

            let contours = getImportantContours(src, MIN_AREA);

            contours.forEach(cnt => {
                // drawCnt(overlay, cnt);
                drawBBRect(overlay, cnt.bbox, randColor());

                cnt.mat.delete();
            });

             cv.imshow('canvasOutput0', orig);
             cv.imshow('canvasOutputOverlay', overlay);

             [orig, src, overlay].forEach(obj => obj.delete())
        }

        function processVideoFull(canvas) {
            let orig = cv.imread(canvas);
            let src = new cv.Mat();

            document.getElementById('resolutionContainer').innerHTML = `${orig.size().width} x ${orig.size().height}`;

            let SCALE = 1.0;
            let MIN_AREA = 3000;


            cv.resize(orig, src, new cv.Size(0, 0), 1 / SCALE, 1 / SCALE, cv.INTER_AREA);

            let overlay = cv.Mat.ones(src.rows, src.cols, cv.CV_8UC3);

            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
            cv.threshold(src, src, 150, 255, cv.THRESH_BINARY);

            let contours = getImportantContours(src, MIN_AREA);

            cv.cvtColor(src, src, cv.COLOR_GRAY2RGB, 0);

            contours.forEach(cnt => {
                drawCnt(overlay, cnt);
            });

            cv.imshow('canvasOutput0', src);
            cv.imshow('canvasOutputOverlay', overlay);

            cutContours(orig, contours, SCALE).slice(0).forEach(item => { // .slice(22)


                cv.cvtColor(item.mat, item.mat, cv.COLOR_RGBA2GRAY, 0);
                cv.threshold(item.mat, item.mat, 130, 255, cv.THRESH_BINARY);

                // let bbb = cv.boundingRect(item.cnt);
                // drawBBRect(overlay, bbb, new cv.Scalar(255, 255, 255));
                let target;

                try {

                    // try {
                        target = findContourAndFixPerspective2(item.mat);

                        if(!target) {
                            return;
                        }
                    // }
                    // catch (e) {
                    //     console.error("FAILED TO FIND PERSPECTIVE");
                    //     return;
                    // }

                    let targetContours = getImportantContours(target.mat, 20, true);
                    let clusters = simpleClusterize(targetContours, 70);
                    console.log('AAAA', targetContours);
                    console.log('CLU', clusters);
                    let tiles = cutTilesFromClusters(target.mat, clusters, false);
                    tiles.forEach(tile => {

                        let cutCanvas = document.getElementById('cutSets').appendChild(document.createElement('canvas'));
                        cv.imshow(cutCanvas, tile.mat);
                    })
                }
                finally {
                    if(target){
                        // let cutCanvas = document.getElementById('cutSets').appendChild(document.createElement('canvas'));
                        // cv.imshow(cutCanvas, target.mat);
                    }
                    // cv.imshow(cutCanvas, item.mat);
                    // throw e;
                }


            });



        }
        

    }


  </script>


</body></html>